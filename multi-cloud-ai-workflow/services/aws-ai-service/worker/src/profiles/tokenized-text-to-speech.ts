import * as AWS from "aws-sdk";
import { McmaException, AIJob, JobAssignment, getTableName, JobParameterBag } from "@mcma/core";
import { ProcessJobAssignmentHelper, ProviderCollection, WorkerRequest } from "@mcma/worker";
import { AwsS3FileLocator, AwsS3FileLocatorProperties, AwsS3FolderLocatorProperties } from "@mcma/aws-s3";

const S3 = new AWS.S3();
const Polly = new AWS.Polly();

function msToTime(duration: string | number) {
    if (typeof duration === "string") {
        duration = parseInt(duration);
    }
    let milliseconds = ((duration % 1000) / 100);
    let seconds = Math.floor((duration / 1000) % 60);
    let minutes = Math.floor((duration / (1000 * 60)) % 60)
    let hours = Math.floor((duration / (1000 * 60 * 60)) % 24);

    let hoursString = hours < 10 ? "0": "" + hours.toString();
    let minutesString = minutes < 10 ? "0" : "" + minutes.toString();
    let secondsString = seconds < 10 ? "0" : "" + seconds.toString();
    let millisecondsString = (milliseconds < 100 ? "0" : "") + (milliseconds < 10 ? "0" : "") + milliseconds.toString();

    return hoursString + ":" + minutesString + ":" + secondsString + "." + millisecondsString;
}

function fromSrt(data) {

    data = data.replace(/\r/g, "");

    var regex = /(\d+)\n(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})/g;
    data = data.split(regex);
//        logger.debug(data);
    data.shift();
//        logger.debug(data);

    var items = "";

    for (var i = 0; i < data.length; i += 4) {

        if (i < (data.length - 4)) {
            items = items +
                    "{" +
                    "\"id\": \"" + data[i].trim() + "\"," +
                    "\"startTime\": \"" + data[i + 1].trim() + "\"," +
                    "\"endTime\": \"" + data[i + 2].trim() + "\"," +
                    "\"text\": \"" + data[i + 3].trim() + "\"" +
                    "},";
        } else if (i === (data.length - 4)) {
            items = items +
                    "{" +
                    "\"id\": \"" + data[i].trim() + "\"," +
                    "\"startTime\": \"" + data[i + 1].trim() + "\"," +
                    "\"endTime\": \"" + data[i + 2].trim() + "\"," +
                    "\"text\": \"" + data[i + 3].trim() + "\"" +
                    "}";
        }
    }
//      logger.debug(items);

    return items;
}

export async function tokenizedTextToSpeech(providers: ProviderCollection, jobAssignmentHelper: ProcessJobAssignmentHelper<AIJob>) {
    const logger = jobAssignmentHelper.logger;

    const jobInput = jobAssignmentHelper.jobInput;
    const inputFile = jobInput.get<AwsS3FileLocatorProperties>("inputFile");
    const voiceId = jobInput.voiceId;
    const jobAssignmentId = jobAssignmentHelper.jobAssignmentId;

    logger.debug("14. Generate SSML file for Polly from Tokenized translation");

    logger.debug("14.1. get input text file from translation service stored in tempBucket (defined in job initiator in step 14");
    const s3Bucket = inputFile.awsS3Bucket;
    const s3Key = inputFile.awsS3Key;
    let s3Object;
    try {
        s3Object = await S3.getObject({
            Bucket: s3Bucket,
            Key: s3Key,
        }).promise();
    } catch (error) {
        throw new McmaException("Unable to read file in bucket '" + s3Bucket + "' with key '" + s3Key + "' due to error: " + error.message);
    }

    logger.debug("14.2. extract text from file");
    const inputText = s3Object.Body.toString();
    logger.debug("translation:", inputText);

    logger.debug("14.3. setup and call polly service to retrieve speechmarks per sentence");
    const params_sm = {
        OutputFormat: "json",
        OutputS3BucketName: jobAssignmentHelper.workerRequest.getRequiredContextVariable<string>("ServiceOutputBucket"),
        OutputS3KeyPrefix: "000-TextTokensSpeechMarksJob-" + jobAssignmentId.substring(jobAssignmentId.lastIndexOf("/") + 1),
        Text: inputText,
        SpeechMarkTypes: ["sentence"],
        VoiceId: voiceId,
        TextType: "text"
    };
    const data = await Polly.startSpeechSynthesisTask(params_sm).promise();

    logger.debug("14.4. visualise data with url to the speechmarks file generated by the service");
    logger.debug(data);

    logger.debug("14.5. OutputS3KeyPrefix used in s3-trigger");
    logger.debug("See regex for textTokenSpeechMarksJob in aws-ai-service/se-trigger/src/index.js");
    logger.debug(params_sm.OutputS3KeyPrefix);


}

export async function processTokenizedTextToSpeechJobResult(providers: ProviderCollection, workerRequest: WorkerRequest) {
    const jobAssignmentHelper = new ProcessJobAssignmentHelper(
        providers.dbTableProvider.get(getTableName(workerRequest), JobAssignment),
        providers.resourceManagerProvider.get(workerRequest),
        providers.loggerProvider.get(workerRequest.tracker),
        workerRequest
    );

    const logger = jobAssignmentHelper.logger;
    try {
        await jobAssignmentHelper.initialize();

        logger.debug("14.6. Retrieve job inputParameters");
        let jobInput = jobAssignmentHelper.jobInput;

        logger.debug("14.7. retrieve speechmarks");
        let s3Bucket = workerRequest.input.outputFile.awsS3Bucket;
        let s3Key = workerRequest.input.outputFile.awsS3Key;
        const speechmarks = await S3.getObject({ Bucket: s3Bucket, Key: s3Key }).promise();
        logger.debug(speechmarks.Body.toString());
        let speechmarks_json_a = "{ \"results\": { \"items\": [" + speechmarks.Body.toString().replace(/}/g, "},") + "]}}";
        let speechmarks_json_b = speechmarks_json_a.replace(/[\n]/g, "");
        let speechmarks_json = speechmarks_json_b.replace(",]", "]");
        logger.debug(speechmarks_json);

        logger.debug("14.8. copy speechmarks in speechmarks json file");
        let s3Bucket_sm = jobInput.get<AwsS3FolderLocatorProperties>("outputLocation").awsS3Bucket;
        let s3Key_sm = jobInput.get<AwsS3FolderLocatorProperties>("outputLocation").awsS3KeyPrefix + "speechmarks.json";
        let s3Params_sm = {
            Bucket: s3Bucket_sm,
            Key: s3Key_sm,
            Body: speechmarks_json
        };
        await S3.putObject(s3Params_sm).promise();

        logger.debug("14.9. transform speechmarks into srt for subtitle offline editing and synchronisation");
        let speechmarksJsonData = JSON.parse(speechmarks_json);
        logger.debug(speechmarksJsonData);

        let speechmarksrt = "";
        for (let j = 0; j < speechmarksJsonData.results.items.length; j++) {
            let ksrt = j + 1;
            if (j + 1 < speechmarksJsonData.results.items.length) {
                let speechmarksJsonDataItem = speechmarksJsonData.results.items[j];
                let speechmarksJsonNextDataItem = speechmarksJsonData.results.items[j + 1];
                let start = msToTime(speechmarksJsonDataItem.time);
                let end = msToTime(speechmarksJsonNextDataItem.time - 10);

                speechmarksrt = speechmarksrt +
                                "\r\n" + ksrt + "\r\n" +
                                start + " --> " + end + "\r\n" +
                                speechmarksJsonDataItem.value;

            } else if (j + 1 === speechmarksJsonData.results.items.length) {
                let speechmarksJsonDataItem = speechmarksJsonData.results.items[j];
                let start = msToTime(speechmarksJsonDataItem.time);
                let end = start + 1000;

                speechmarksrt = speechmarksrt +
                                "\r\n" + j + "\r\n" +
                                start + " --> " + end + "\r\n" +
                                speechmarksJsonDataItem.value;
            }

        }
        logger.debug(speechmarksrt);

        logger.debug("14.10. save speechmarks srt into a speechmarks.srt file under temp/AIResults/SSML");
        let s3Bucket_smsrt = jobInput.get<AwsS3FolderLocatorProperties>("outputLocation").awsS3Bucket;
        let s3Key_smsrt = jobInput.get<AwsS3FolderLocatorProperties>("outputLocation").awsS3KeyPrefix + "speechmarks.srt";
        let s3Params_smsrt = {
            Bucket: s3Bucket_smsrt,
            Key: s3Key_smsrt,
            Body: speechmarksrt
        };
        await S3.putObject(s3Params_smsrt).promise();


        logger.debug("14.11. get edited/synched srt of translation after alignment with srt_output_clean from temp/srt bucket and timing adjustment, inserting srt_translation_output(_synched).srt in the workflow");
        const s3Bucket_syncsrt = jobInput.get<AwsS3FolderLocatorProperties>("outputLocation").awsS3Bucket;
//        const s3Key_syncsrt = "srt/srt_translation_output_synched.srt";
        const s3Key_syncsrt = "srt/srt_translation_output.srt";
        let s3Object_syncsrt;
        try {
            s3Object_syncsrt = await S3.getObject({
                Bucket: s3Bucket_syncsrt,
                Key: s3Key_syncsrt,
            }).promise();
        } catch (error) {
            throw new McmaException("Unable to read file in bucket '" + s3Bucket_syncsrt + "' with key '" + s3Key_syncsrt + "' due to error: " + error.message);
        }

        logger.debug("14.12. retrieve and jsonify text from srt_translation_output(_synched).srt and format as valid parsable json");
        const jsonfromsrt = fromSrt(s3Object_syncsrt.Body.toString());
//        logger.debug(jsonfromsrt);
        const syncSrtJson = "{ \"results\": {\"items\": [" + jsonfromsrt.toString() + "]}}";
        logger.debug(syncSrtJson);

        const syncSrtJsonData = JSON.parse(syncSrtJson);
        logger.debug(syncSrtJsonData);

        logger.debug("14.13. generate SSML file with breaks and translation sentences from speech marks and timings from stt");
        let ssldata = "<speak>";

        for (var j = 0; j < syncSrtJsonData.results.items.length; j++) {
            let item = syncSrtJsonData.results.items[j];

            let itemstart = item.startTime;
            itemstart = itemstart.replace(",", ".");
//            logger.debug(itemstart);
            let itemstartsplit = itemstart.split(":");
//            logger.debug(itemstartsplit);
            let itemstartms = parseInt(itemstartsplit[0]) * 3600000 + parseInt(itemstartsplit[1]) * 60000 + parseFloat(itemstartsplit[2]) * 1000;
//            logger.debug(itemstartms);
            let itemend = item.endTime;
            itemend = itemend.replace(",", ".");
//            logger.debug(itemend);
            let itemendsplit = itemend.split(":");
            let itemendms = parseInt(itemendsplit[0]) * 3600000 + parseInt(itemendsplit[1]) * 60000 + parseFloat(itemendsplit[2]) * 1000;
//            logger.debug(itemendms);

            let breakTime = 0;
            let breakTimeSecond = 0;

            if (j === 0 && itemstartms > 0) {

                breakTime = itemstartms / 1000;
                breakTimeSecond = breakTime;

                ssldata = ssldata + "<break time=\"" + breakTimeSecond + "s\"/>";

                if (j + 1 < syncSrtJsonData.results.items.length) {
                    let m = j + 1;
                    let nextitem1 = syncSrtJsonData.results.items[m];
                    let nextitem1start = nextitem1.startTime;
                    let nextitem1startsplit = nextitem1start.split(":");
                    let nextitem1startms = parseInt(nextitem1startsplit[0]) * 3600000 + parseInt(nextitem1startsplit[1]) * 60000 + parseFloat(nextitem1startsplit[2]) * 1000;
                    breakTime = ((nextitem1startms - itemendms) / 1000);
                    if (breakTime < 0) {
                        breakTime = 0;
                    }
                    breakTimeSecond = breakTime;

                    ssldata = ssldata + item.text + "<break time=\"" + breakTimeSecond + "s\"/>";
                }
            } else if (j + 1 < syncSrtJsonData.results.items.length) {
                let m = j + 1;
                let nextitem = syncSrtJsonData.results.items[m];
                let nextitemstart = nextitem.startTime;
                let nextitemstartsplit = nextitemstart.split(":");
                let nextitemstartms = parseInt(nextitemstartsplit[0]) * 3600000 + parseInt(nextitemstartsplit[1]) * 60000 + parseFloat(nextitemstartsplit[2]) * 1000;
                breakTime = ((nextitemstartms - itemendms) / 1000);
                if (breakTime < 0) {
                    breakTime = 0;
                }
                breakTimeSecond = breakTime;

                ssldata = ssldata + item.text + "<break time=\"" + breakTimeSecond + "s\"/>";

            } else if (j + 1 === syncSrtJsonData.results.items.length) {
                ssldata = ssldata + item.text;
            }
//            logger.debug(ssldata);
        }

        ssldata = ssldata + "</speak>";

        logger.debug("14.14. visualise SSML data");
        logger.debug(ssldata);

        logger.debug("14.15. save ssml data into a ssml.txt file");
        let s3Bucket_ssml = jobInput.get<AwsS3FolderLocatorProperties>("outputLocation").awsS3Bucket;
        let s3Key_ssml = jobInput.get<AwsS3FolderLocatorProperties>("outputLocation").awsS3KeyPrefix + "ssml.txt";
        let s3Params_ssml = {
            Bucket: s3Bucket_ssml,
            Key: s3Key_ssml,
            Body: ssldata
        };
        await S3.putObject(s3Params_ssml).promise();

        logger.debug("14.16. updating JobAssignment with jobOutput -> ssml txt file");
        jobAssignmentHelper.jobOutput.set("outputFile", new AwsS3FileLocator({
            awsS3Bucket: s3Bucket_ssml,
            awsS3Key: s3Key_ssml
        }));

        await jobAssignmentHelper.complete();


    } catch (error) {
        logger.error(error);
        try {
            await jobAssignmentHelper.fail(error.message);
        } catch (error) {
            logger.error(error);
        }
    }


    logger.debug("14.17. clean up service output file");
    try {
        await S3.deleteObject({
            Bucket: workerRequest.input.outputFile.awsS3Bucket,
            Key: workerRequest.input.outputFile.awsS3Key,
        }).promise();
    } catch (error) {
        console.warn("Failed to cleanup ssml translation output file");
    }

}